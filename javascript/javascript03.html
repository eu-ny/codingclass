<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>자바스크립트 : 데이터 실행하기</title>

    <link rel="stylesheet" href="assets/css/style.css">
    <link rel="stylesheet" href="assets/css/deracula.css">
</head>

<body>
    <header id="header">
        <h1><a href="index.html">Javascript</a></h1>
        <nav class="header_nav">
            <ul>
                <li><a href="javascript01.html">데이터 저장하기</a></li>
                <li><a href="javascript02.html">데이터 불러오기</a></li>
                <li class="active"><a href="javascript03.html">데이터 실행하기</a></li>
                <li><a href="javascript04.html">데이터 제어하기</a></li>
            </ul>
            <ul>
                <li><a href="javascript05.html">문자열 객체</a></li>
                <li><a href="javascript06.html">배열 객체</a></li>
                <li><a href="javascript07.html">수학 객체</a></li>
                <li><a href="javascript08.html">숫자 객체</a></li>
                <li><a href="javascript09.html">브라우저 객체</a></li>
                <li><a href="javascript10.html">요소 객체</a></li>
                <li><a href="javascript11.html">이벤트 객체</a></li>
                <li><a href="javascript12.html">제이쿼리</a></li>
            </ul>
            <ul class="effect">
                <li><a href="effect/searchEffect.html">검색 효과</a></li>
                <li><a href="effect/quizEffect.html">퀴즈 효과</a></li>
                <li><a href="effect/dataEffect.html">데이터 효과</a></li>
                <li><a href="effect/mousEffect.html">마우스 효과</a></li>
                <li><a href="effect/sliderEffect.html">슬라이드 효과</a></li>
                <li><a href="effect/parallaxEffect.html">패랠랙스 효과</a></li>
                <li><a href="effect/gameEffect.html">게임 효과</a></li>
            </ul>
        </nav>
    </header>
    <!-- //header -->
    <main id="main">
        <div class="container">
            <div class="main_menu">
                <ul>
                    <li><a href="#sample01">01. 선언적 함수</a></li>
                    <li><a href="#sample02">02. 익명 함수</a></li>
                    <li><a href="#sample03">03. 매개변수 함수</a></li>
                    <li><a href="#sample04">04. 리턴값 함수</a></li>
                    <li><a href="#sample05">05. 화살표 함수 : 선언적 함수</a></li>
                    <li><a href="#sample06">06. 화살표 함수 : 익명 함수</a></li>
                    <li><a href="#sample07">07. 화살표 함수 : 매개변수 함수</a></li>
                    <li><a href="#sample08">08. 화살표 함수 : 리턴값 함수</a></li>
                    <li><a href="#sample09">09. 화살표 함수 : 익명 함수 + 매개변수 + 리턴값</a></li>
                    <li><a href="#sample10">10. 화살표 함수 : 익명 함수 + 매개변수 + 리턴값 + 괄호 생략</a></li>
                    <li><a href="#sample11">11. 화살표 함수 : 익명 함수 + 매개변수 + 리턴값 + 괄호 생략 + 리턴 생략</a></li>
                    <li><a href="#sample12">12. 화살표 함수 : 선언적 함수 + 매개변수 + 리턴값 + 괄호 생략</a></li>
                    <li><a href="#sample13">13. 함수 유형 : 함수와 매개변수를 이용한 형태</a></li>
                    <li><a href="#sample14">14. 함수 유형 : 함수와 변수를 이용한 형태</a></li>
                    <li><a href="#sample15">15. 함수 유형 : 함수와 배열,객체를 이용한 형태</a></li>
                    <li><a href="#sample16">16. 함수 유형 : 객체 안에 변수와 함수를 이용한 형태</a></li>
                    <li><a href="#sample17">17. 함수 유형 : 객체 생성자 함수</a></li>
                    <li><a href="#sample18">18. 함수 유형 : 프로토타입 함수</a></li>
                    <li><a href="#sample19">19. 함수 유형 : 객체 리터럴 함수</a></li>
                    <li><a href="#sample20">20. 즉시 실행 함수</a></li>
                    <li><a href="#sample21">21. 파라미터 함수</a></li>
                    <li><a href="#sample22">22. 아규먼트 함수</a></li>
                    <li><a href="#sample23">23. 재귀 함수</a></li>
                    <li><a href="#sample24">24. 콜백 함수 : 다른 함수에 인수가 넘겨지는 함수</a></li>
                    <li><a href="#sample25">25. 콜백 함수 : 반복문</a></li>
                    <li><a href="#sample26">26. 콜백 함수 : 동기 / 비동기</a></li>
                    <li><a href="#sample26">26. promise 함수 : 콜백함수를 정리하기 위해 사용하는 함수</a></li>
                    <li><a href="#sample27">27. 내부 함수 : 스코프, 클로져와 관련돤 함수</a></li>
                    <li><a href="#sample28">28. 클래스</a></li>
                </ul>
            </div>
            <div class="main_sample">
                <div id="sample01" class="sample">
                    <h3>01. 선언적 함수</h3>
                    <p>
                        변수(데이터 저장), 배열(데이터 저장), 객체(데이터 저장, 내장 객체(three.js 등등 자바스크립트 안에서 작동되는 것)) -> 함수(실행문) (제어문) 를 이용한다.
                    </p>
                    <div class="script"></div>
<pre><code class="language-js">{
    function func(){
        document.write("함수가 실행되었습니다.1<br>")
        //write도 객체이자 메소드이다 → 브라우저 객체
    }
    func();
}
</code></pre>
                    <div class="result">
                        <details>
                            <summary>결과 보기</summary>
                            <div class="sample01_result">
                                함수가 실행되었습니다.1
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample01 -->

                <div id="sample02" class="sample">
                    <h3>02. 익명 함수</h3>
                    <p class="t_box">
                        &lt;자료형 데이터 타입&gt;<br>
                        const x = 100;<br>
                        const x1 = "100";<br>
                        const x2 = [];<br>
                        const x3 = {};<br>
                        const x4 = null, undefined;<br>
                        const x5 = function(){}; -&gt; 함수<br>
                        const x6 = true, false;<br>
                    </p>
                    <div class="script"></div>
<pre><code class="language-js">{
    const func = function(){      //함수 안에 이름이 없어서 익명함수 이다.
        document.write("함수가 실행되었습니다.2<br>");
    }
    func();
}
</code></pre>
                    <div class="result">
                        <details>
                            <summary>결과 보기</summary>
                            <div class="sample02_result">
                                함수가 실행되었습니다.1
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample02 -->

                <div id="sample03" class="sample">
                    <h3>03. 매개변수 함수</h3>
                    <p class="t_box">
                        함수의 매개변수(parameter)란 함수를 호출할 때 <i>인수로 전달된 값을 함수 내부에서 사용</i>할 수 있게 해주는 변수이다.
                    </p>
                    <div class="script"></div>
<pre><code class="language-js">{
    function func(str){     //str = 변수 = 인자 = 매개변수
        document.write(str);
    }
    func("함수가 실행되었습니다.3<br>"); // func안에 변수명을 지정할 수 있다.
}
</code></pre>
                    <div class="result">
                        <details>
                            <summary>결과 보기</summary>
                            <div class="sample03_result">
                                함수가 실행되었습니다.3
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample03 -->

                <div id="sample04" class="sample">
                    <h3>04. 리턴 값 함수</h3>
                    <p class="t_box">
                        함수가 어떠한 기능을 수행하고 그 <i>결과를 호출한 곳으로 돌려주는 값</i>을 리턴값이라고 한다.<br>
                        또한 출력 명령어를 사용하지 않고 출력하기 위해서는 리턴값 함수를 사용해주면 된다.
                    </p>
                    <div class="script"></div>
<pre><code class="language-js">{
    function func(){
        const str = "함수가 실행되었습니다.4<br>"
        return str;
    }
    document.write(func());
    //객체로 데이터를 저장하는 방법 중 객체 속에 함수로 표현하는 방법과 같은 맥락이다.
    //다른 식에서도 리턴은 거의 생략한다. 리액트에서는 보통 리턴까지 사용하여 입력한다.
}
</code></pre>
                    <div class="result">
                        <details>
                            <summary>결과 보기</summary>
                            <div class="sample04_result">
                                함수가 실행되었습니다.4
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample04 -->

                <div id="sample05" class="sample">
                    <h3>05. 화살표 함수 (선언적 함수)</h3>
                    <p class="t_box">
                        ECMAscript6(es6)에 추가된 내용으로 <i>" =&gt;"를 이용하여 함수를 간결하게 표현</i>할 때 사용한다.<br>
                        function 키워드를 생략할 수 있으며 항상 <i>익명 함수 형식</i>으로 표현해야 한다. 이때 단일 명령문이라면 함수의 중괄호 {}와 return의 생략이 가능하다.
                    </p>
                    <div class="script"></div>
<pre><code class="language-js">{
    //화살표 함수(선언적 함수) 기본표현
    func = () =&gt; {
        document.write("함수가 실행되었습니다.5<br>");
    }
    func();

    //화살표 함수(선언적 함수) 한줄 표현
    func = () =&gt; document.write("함수가 실행되었습니다.5<br>"); //{}가 생략되어도 읽는다.

    func();
}
</code></pre>
                    <div class="result">
                        <details>
                            <summary>결과 보기</summary>
                            <div class="sample05_result">
                                함수가 실행되었습니다.5
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample05 -->

                <div id="sample06" class="sample">
                    <h3>06. 화살표 함수 (익명 함수)</h3>
                    <p class="t_box">
                        화살표 함수에서 익명 함수는 const를 사용하여 표현해야 한다.
                    </p>
                    <div class="script"></div>
<pre><code class="language-js">{
    //화살표 함수 익명함수 기본 표현
    const func = () =&gt; {
        document.write("함수가 실행되었습니다.6<br>");
    }
    
    //화살표 함수 익명함수 단일 표현
    const func = () =&gt;  document.write("함수가 실행되었습니다.6<br>");

    func();
}
</code></pre>
                    <div class="result">
                        <details>
                            <summary>결과 보기</summary>
                            <div class="sample06_result">
                                함수가 실행되었습니다.6
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample06 -->

                <div id="sample07" class="sample">
                    <h3>07. 화살표 함수 (매개변수 함수)</h3>
                    <p class="t_box">
                        화살표 함수에서 변수 선언을 해주어야 하지만 생략이 가능하다.
                    </p>
                    <div class="script"></div>
<pre><code class="language-js">{
    //화살표 함수 익명함수 기본 표현
    const func = () =&gt; {
        document.write("함수가 실행되었습니다.6<br>");
    }
    
    //화살표 함수 익명함수 단일 표현
    const func = () =&gt;  document.write("함수가 실행되었습니다.6<br>");

    func();
}
</code></pre>
                    <div class="result">
                        <details>
                            <summary>결과 보기</summary>
                            <div class="sample07_result">
                                함수가 실행되었습니다.7
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample07 -->

                <div id="sample08" class="sample">
                    <h3>08. 화살표 함수 (리턴값 함수)</h3>
                    <div class="script"></div>
<pre><code class="language-js">{
    func = () =&gt; {
        const str = "함수가 실행되었습니다.8<br>";
        return str;
    }
    document.write(func());
}
</code></pre>
                    <div class="result">
                        <details>
                            <summary>결과 보기</summary>
                            <div class="sample08_result">
                                함수가 실행되었습니다.8
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample08 -->

                <div id="sample09" class="sample">
                    <h3>09. 화살표 함수 : 익명 함수 + 매개변수 + 리턴값</h3>
                    <p class="t_desc">const를 앞에 입력해주어야 익명 함수가 된다. </p>
                    <div class="script"></div>
<pre><code class="language-js">{
    const func = (str) =&gt; {
        return str;
    }
    document.write(func("함수가 실행되었습니다.9"));
}
</code></pre>
                    <div class="result">
                        <details>
                            <summary>결과 보기</summary>
                            <div class="sample09_result">
                                함수가 실행되었습니다.9
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample09 -->

                <div id="sample10" class="sample">
                    <h3>10. 화살표 함수 : 익명 함수 + 매개변수 + 리턴값 + 괄호 생략</h3>
                    <p class="t_desc">()를 없앤 화살표 함수</p>
                    <div class="script"></div>
<pre><code class="language-js">{
    const func = str =&gt; {
        return str;
    }
    document.write(func("함수가 실행되었습니다.10"));
}
</code></pre>
                    <div class="result">
                        <details>
                            <summary>결과 보기</summary>
                            <div class="sample10_result">
                                함수가 실행되었습니다.10
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample10 -->

                <div id="sample11" class="sample">
                    <h3>11. 화살표 함수 : 익명 함수 + 매개변수 + 리턴값 + 괄호 생략 + 리턴 생략</h3>
                    <p class="t_desc">() 과 {} 를 모두 생략한 화살표 함수 - 익명</p>
                    <div class="script"></div>
<pre><code class="language-js">{
    const func = str =&gt; str;

    document.write(func("함수가 실행되었습니다.11"));
}
</code></pre>
                    <div class="result">
                        <details>
                            <summary>결과 보기</summary>
                            <div class="sample11_result">
                                함수가 실행되었습니다.11
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample11 -->

                <div id="sample12" class="sample">
                    <h3>12. 화살표 함수 : 선언적 함수 + 매개변수 + 리턴값 + 괄호 생략 + 리턴 생략</h3>
                    <p class="t_desc">() 과 {} 를 모두 생략한 화살표 함수 - 선언적함수 (const를 생략해주면 된다.)</p>
                    <div class="script"></div>
<pre><code class="language-js">{
    func = str =&gt; str;

    document.write(func("함수가 실행되었습니다.12"));
}
</code></pre>
                    <div class="result">
                        <details>
                            <summary>결과 보기</summary>
                            <div class="sample12_result">
                                함수가 실행되었습니다.12
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample12 -->

                <div id="sample13" class="sample">
                    <h3>13. 함수와 매개변수를 이용한 형태 : 매개변수를 통해 데이터 전달</h3>
                    <p class="t_desc">매개변수를 통해 데이터를 전달시킨다.</p>
                    <p class="t_desc">
                        <strong>함수의 특징</strong><br>
                        1. 함수는 실행문의 집합체이다.<br>
                        2. 함수를 재활용하는 것이 목적이다.
                    </p>
                    <div class="script"></div>
<pre><code class="language-js">function func(num, str1, str2){
    document.write(num + ". " + str1 + "가 " + str2 + "되었습니다.13");
}
func("1", "함수", "실행");
func("2", "자바스크립트", "실행"); //재활용 : 함수를 두 번 쓸 필요가 없다. 
func("3", "제이쿼리", "실행");
</code></pre>
                    <div class="result">
                        <details>
                            <summary>결과 보기</summary>
                            <div class="sample13_result">
                                1. 함수가 실행되었습니다.13
                                2. 자바스크립트가 실행되었습니다.13
                                3. 제이쿼리가 실행되었습니다.13
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample13 -->

                <div id="sample14" class="sample">
                    <h3>14. 함수 유형 : 함수와 변수를 이용한 형태</h3>
                    <p class="t_desc">변수를 통해 데이터를 전달시킨다.</p>
                    <div class="script"></div>
<pre><code class="language-js"> function func(num, str1, str2){
    document.write(num + ". " + str1 + "가 " + str2 + "되었습니다.14");
}
const youNum1 = 1;
const youNum2 = 2;
const youNum3 = 3;
const youStr1 = "함수";
const youStr2 = "자바스크립트";
const youStr3 = "제이쿼리";
const youCom1 = "실행";

func(youNum1, youStr1, youCom1);
func(youNum2, youStr2, youCom1);
func(youNum3, youStr3, youCom1);
</code></pre>
                    <div class="result">
                        <details>
                            <summary>결과 보기</summary>
                            <div class="sample13_result">
                                1. 함수가 실행되었습니다.14
                                2. 자바스크립트가 실행되었습니다.14
                                3. 제이쿼리가 실행되었습니다.14
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample14 -->

                <div id="sample15" class="sample">
                    <h3>15. 함수 유형 : 함수와 배열 , 객체를 이용한 형태 </h3>
                    <p class="t_desc">객체를 사용하여 데이터를 전달시킨다.</p>
                    <div class="script">
<pre><code class="language-js">function func(num, str1, str2){
    document.write(num + ". " + str1 + "가 " + str2 + "되었습니다.15");
}

const info = [
    {
        num :  "1",
        name :  "함수",
        com :  "실행"
    },
    {
        num :  "2",
        name :  "자바스트립트",
        com :  "실행"
    },
    {
        num :  "3",
        name :  "제이쿼리",
        com :  "실행"
    }
];
func(info[0].num, info[0].name, info[0].com);
func(info[1].num, info[1].name, info[1].com);
func(info[2].num, info[2].name, info[2].com);
</code></pre>
                    </div>
                    <div class="result">
                        <details>
                            <summary>결과 보기</summary>
                            <div class="sample13_result">
                                1. 함수가 실행되었습니다.15
                                2. 자바스크립트가 실행되었습니다.15
                                3. 제이쿼리가 실행되었습니다.15
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample15 -->

                <div id="sample16" class="sample">
                    <h3>16. 함수 유형 : 객체 안에 변수와 함수를 이용한 형태</h3>
                    <p class="t_desc">
                        객체가 하나가 있을 땐 info 뒤에 []를 사용하지 않는다.<br>
                        16번 유형은 재사용이 불가하기 때문에 아래의 17번 식이 만들어지게 되었다.
                    </p>
                    <div class="script"></div>
<pre><code class="language-js">const info = {
    num1 : 1,
    name1 : "함수",
    word1 : "실행",
    num2 : 2,
    name2 : "자바스크립트",
    word2 : "실행",
    num3 : 3,
    name3 : "제이쿼리",
    word3 : "실행",

    result1 : function(){    
        //객체 안에 함수를 넣은 상태 
        document.write(info.num1 + ". " + info.name1 + "가 " + info.word1 + "되었습니다.16");
    },
    result2 : function(){    
        //객체 안에 함수를 넣은 상태 
        document.write(info.num2 + ". " + info.name2 + "가 " + info.word2 + "되었습니다.16");
    },
    result3 : function(){    
        //객체 안에 함수를 넣은 상태 
        document.write(info.num3 + ". " + info.name3 + "가 " + info.word3 + "되었습니다.16");
    }
}
info.result1(); 
info.result2(); 
info.result3(); 
</code></pre>
                    <div class="result">
                        <details>
                            <summary>결과 보기</summary>
                            <div class="sample13_result">
                                1. 함수가 실행되었습니다.16
                                2. 자바스크립트가 실행되었습니다.16
                                3. 제이쿼리가 실행되었습니다.16
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample16 -->

                <div id="sample17" class="sample">
                    <h3>17. 함수 유형 : 객체 생성자 함수</h3>
                    <p class="t_desc">16번의 단점인 재사용을 위해 새로 만들어진 객체 생성자 함수이다.</p>
                    <p class="t_desc">
                        <strong>객체 생성자 함수의 특징</strong><br>
                        1.this. : 이것을 저장하시오. 라는 의미로 재사용을 가능하게 해준다.
                        2,객체 생성자를 출력하려면 꼭 인스턴트를 생성 한뒤 실행문을 써주어야 한다.
                    </p>
<pre><code class="language-js">function func(num, name, word){ //저장한 데이터를 변수에게 데이터 전달
    this.num = num; //재사용울 위해 const를 생략하고 this.를 붙인다.
    this.name = name;
    this.word = word;

    this.result = function(){
        document.write(this.num + ". " + this.name + "가 " + this.word + "되었습니다.17<br>");
    }
}

//인스턴트 생성 - 데이터 저장
const info1 = new func("1", "함수", "실행"); //데이터 저장  : this. : 이것을 저장하시오. 라는 의미!
const info2 = new func("2", "자바스크립트", "실행");
const info3 = new func("3", "제이쿼리", "실행");

//실행

info1.result();
info2.result();
info3.result();
</code></pre>
                    <div class="result">
                        <details>
                            <summary>결과 보기</summary>
                            <div class="sample13_result">
                                1. 함수가 실행되었습니다.17
                                2. 자바스크립트가 실행되었습니다.17
                                3. 제이쿼리가 실행되었습니다.17
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample17 -->

                <div id="sample18" class="sample">
                    <h3>18. 함수 유형 : 프로토타입 함수</h3>
                    <p class="t_desc">데이터에 이어 메모리까지 재사용을 하기 위해 나온 함수 - 쓸데없는 데이터 사용하지 않도록!</p>
                    <div class="script">
<pre><code class="language-js"> function func(num, name, word){ //저장한 데이터를 변수에게 데이터 전달
    this.num = num; //재사용울 위해 const를 생략하고 this.를 붙인다.
    this.name = name;
    this.word = word;
}
func.prototype.result = function(){
    document.write(this.num + ". " + this.name + "가 " + this.word + "되었습니다.18<br>");
}

//인스턴트 생성 - 데이터 저장
const info1 = new func("1", "함수", "실행"); //데이터 저장  : this. : 이것을 저장하시오. 라는 의미!
const info2 = new func("2", "자바스크립트", "실행");
const info3 = new func("3", "제이쿼리", "실행");

//실행
info1.result();
info2.result();
info3.result();
</code></pre>
                    </div>
                    <div class="result">
                        <details>
                            <summary>결과 보기</summary>
                            <div class="sample13_result">
                                1. 함수가 실행되었습니다.18
                                2. 자바스크립트가 실행되었습니다.18
                                3. 제이쿼리가 실행되었습니다.18
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample18 -->

                <div id="sample19" class="sample">
                    <h3>19. 함수 유형 : 객체 리터럴 함수</h3>
                    <p class="t_desc">함수를 리터럴 객체 안에 넣기 : 원하는 값만 추출하기 용이함!.</p>
                    <div class="script"></div>
<pre><code class="language-js">function func(num, name, word){ //저장한 데이터를 변수에게 데이터 전달
    this.num = num; //재사용을 위해 const를 생략하고 this.를 붙인다.
    this.name = name;
    this.word = word;
}
func.prototype = {
    result1 : function(){
        document.write(this.num + ". " + this.name + "가 " + this.word + "되었습니다.19<br>");
    },
    result2 : function(){
        document.write(this.num + ". " + this.name + "가 " + this.word + "되었습니다.19<br>");
    },
    result3 : function(){
        document.write(this.num + ". " + this.name + "가 " + this.word + "되었습니다.19<br>");
    }
}

//인스턴트 생성 - 데이터 저장
const info1 = new func("1", "함수", "실행"); //데이터 저장  : this. : 이것을 저장하시오. 라는 의미!
const info2 = new func("2", "자바스크립트", "실행");
const info3 = new func("3", "제이쿼리", "실행");

//실행
info1.result1();
info2.result2();
info3.result3();
</code></pre>
                    <div class="result">
                        <details>
                            <summary>결과 보기</summary>
                            <div class="sample13_result">
                                1. 함수가 실행되었습니다.19
                                2. 자바스크립트가 실행되었습니다.19
                                3. 제이쿼리가 실행되었습니다.19
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample19 -->

                <div id="sample20" class="sample">
                    <h3>20. 함수 유형 : 즉시 실행 함수</h3>
                    <p class="t_desc">함수를 더 간편하게 만든 식으로 func();(실행문)을 생략합니다. </p>
                    <div class="script"></div>
<pre><code class="language-js">{
//즉시실행 함수
(function func (){
    document.write("1. 함수가 실행되었습니다.20")
})();

//즉시실행 함수 화살표 함수
(() =&gt; {
    document.write("2. 함수가 실행되었습니다.20")
})();
}
</code></pre>
                    <div class="result">
                        <details>
                            <summary>결과 보기</summary>
                            <div class="sample13_result">
                                1. 함수가 실행되었습니다.20
                                2. 함수가 실행되었습니다.20
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample20 -->

                <div id="sample21" class="sample">
                    <h3>21. 함수 유형 : 파라미터 함수</h3>
                    <p class="t_desc"></p>
                    <div class="script"></div>
<pre><code class="language-js">{
//매개변수 함수
function fun(str){
    document.write(str);
}
func("1. 함수가 실행되었습니다.21");

//파라미터 함수 : 매개변수 함수를 파라미터 함수로 바꾸기.
function func(str = "2. 함수가 실행되었습니다.21"){
    document.write(str);
}
func();
}
</code></pre>
                    <div class="result">
                        <details>
                            <summary>결과 보기</summary>
                            <div class="sample13_result">
                                1. 함수가 실행되었습니다.21
                                2. 함수가 실행되었습니다.21
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample21 -->

                <div id="sample22" class="sample">
                    <h3>22. 함수 유형 : 아규먼트 함수</h3>
                    <div class="script"></div>
<pre><code class="language-js">{
    function func(a,b){
        document.write(argyments[0]);   //a
        document.write(argyments[1]);   //b
    }
    func("1.함수가 실행되었습니다.22","2.함수가 실행되었습니다.22");
}
</code></pre>
                    <div class="result">
                        <details>
                            <summary>결과 보기</summary>
                            <div class="sample13_result">
                                1. 함수가 실행되었습니다.22
                                2. 함수가 실행되었습니다.22
                            </div>
                        </details>
                    </div>
                </div>
                <!-- //sample22 -->

                <div id="sample23" class="sample">
                    <h3>23. 함수 유형 : 재귀 함수 : 자기 자신을 호출시킨다.</h3>
                    <p>
                        동시에 여러개 실행 즉 한번에 여러개의 함수를 동시에 실행
                    </p>
<pre><code class="language-js">//반복적으로 사용할 경우
{
    function func(num) {
        if( num &lt;= 1){
            document.write("함수가 실행되었습니다." + num);
        } else {
            document.write("함수가 실행되었습니다."+ num);
            func(num -1);
        }

    }

    func(10);
}

//애니메이션을 사용할 경우 1초에 60번실행이라는 기본 조건이 있기 때문에 무한대로 빠지지 않는다.
{
    function animation(){
        document.write("함수가 실행되었습니다.");

        requestAnimationFrame(animation)
    }
    animation();
}
</code></pre>
                    <div class="result">
                        <details>
                            <summary>결과 보기</summary>
                               함수가 실행되었습니다.  함수가 실행되었습니다.......................
                        </details>
                    </div>
                </div>
                <!-- //sample23 -->

                <div id="sample24" class="sample">
                    <h3>24. 함수 유형 : 콜백 함수 : 다른 함수에 인수로 넘겨지는 함수 : 정석 버젼~! 📌</h3>
                    <p class="t_desc">
                        로딩 소스가 실행이 된 후 그 다음에 함수를 실행시키고 싶을 때 콜백함수를 사용한다.<br>
                        2번(로딩소스)가 끝나고 1번 실행 : 즉 첫번째 함수가 실행 -> 두번째 함수가 실행 : 즉 순서대로 실행
                    </p>
<pre><code class="language-js">{
    function func() {
        document.write("함수가 실행되었습니다.1");
    }
    //매개변수(인자값) 사용하여 마치 함수처럼 사용
    function callback(str) {
        document.write("함수가 실행되었습니다.2");
        str();
    }

    callback(func);

    //콜백이 실행되고 그 뒤 func가 실행된다. 즉 인자값을 이용하여 마치 함수처럼 사용하였기 때문이다. 실무에서 많이 사용
}
</code></pre>
                    <div class="result">
                        <details>
                            <summary>결과 보기</summary>
                            함수가 실행되었습니다.2 함수가 실행되었습니다.1
                        </details>
                    </div>
                </div>
                <!-- //sample24 -->

                <div id="sample25" class="sample">
                    <h3>25. 함수 유형 : 콜백 함수 : 반복문 📌</h3>
                    <p class="t_desc">
                        콜백함수로 반복문을 실행 시키기
                    </p>
<pre><code class="language-js">{
    function func(index) {
        document.write("함수가 실행되었습니다." + index);
    }

    function callback(num) {
       for(let i=1; i&lt;=10; i++){
           num(i);
        }
    }

    callback(func);
}
</code></pre>
                    <div class="result">
                        <details>
                            <summary>결과 보기</summary>
                            함수가 실행되었습니다.1함수가 실행되었습니다.2함수가 실행되었습니다.3함수가 실행되었습니다.4함수가 실행되었습니다.5함수가 실행되었습니다.6함수가 실행되었습니다.7함수가 실행되었습니다.8함수가 실행되었습니다.9함수가 실행되었습니다.10
                        </details>
                    </div>
                </div>
                <!-- //sample25 -->

                <div id="sample26" class="sample">
                    <h3>26. 함수 유형 : 콜백 함수 : 동기/비동기 📌</h3>
                    <p class="t_desc">
                        콜백함수 사용 시 : 원래 b가 먼저 실행된 후 a가 실행되어야 하지만 매개변수로 콜백을 사용하여서 실행문인 것 처럼 사용한다. <br> 그러면 a가 먼저 실행된 후 b가 실행된다. 즉 b도 3초 뒤에 a가 끝나고 b가 실행되는 것<br>
                        콜백함수의 용도는 순차적으로 코드를 실행시키기 위함. 콜백함수에 사용할 수 있는 함수는 대표적으로 이벤트 리스너와 셋타임아웃 등이 있다.<br>
                        콜백함수의 원리 : funcA 실행 해라. 그러나 실행 후 파리미터로 콜백을 넣어서 : 굳이 콜백 함수를 사용해서 순차적으로 사용하는 이유는 협업을 했을 때 각각 출력하고자 하는 값이 다를 때 콜백함수를 이용해서 원하는대로 순서를 바꿀 수 있기 때문.
                    </p>
<pre><code class="language-js">function funcA(){
    setTimeout(() =&gt; {
       console.log("funcA가 실행되었습니다.");
    },1000); //1초 후에 실행됨.
}
function funcB(){
    console.log("funcB가 실행되었습니다.");
}

funcA();
funcB();

//b
//a
</code></pre>
<pre><code class="language-js">//비동기
function funcA(callback){
    setTimeout(() =&gt; {
       console.log("funcA가 실행되었습니다.");
       callback(); //실행문인 것처럼 훼이크
    }, 1000); //1초 후에 실행됨.
}
function funcB(){
    console.log("funcB가 실행되었습니다.");
}
funcA(function(){
    funcB();
});

//a
//b

{
    function funcA(callback){
        setTimeout(() =&gt; {
           console.log("funcA가 실행되었습니다.");
           callback();
        }, 1000);
    }
    function funcB(callback){
        setTimeout(() =&gt; {
           console.log("funcB가 실행되었습니다.");
           callback();
        }, 1000);
    }
    function funcC(callback){
        setTimeout(() =&gt; {
           console.log("funcC가 실행되었습니다.");
           callback();
        }, 1000);
    }
    function funcD(callback){
        setTimeout(() =&gt; {
           console.log("funcD가 실행되었습니다.");
           callback();
        }, 1000);
    }
    function funcE(){
        console.log("funcE가 실행되었습니다.");
    }
    funcA(function(){
        funcB(function(){
            funcC(function(){
                funcD(function(){
                    funcE();
                });
            });
        });
    });

    //a
    //b
    //c
    //d
    //e
}

</code></pre>
                    <div class="result">
                        <details>
                            <summary>결과 보기</summary>
                        </details>
                    </div>
                </div>
                <!-- //sample26 -->

                <div id="sample27" class="sample">
                    <h3>27. 함수 유형 : promise함수 : </h3>
                    <p class="t_desc">
                    </p>
<pre><code class="language-js">
</code></pre>
                    <div class="result">
                        <details>
                            <summary>결과 보기</summary>
                        </details>
                    </div>
                </div>
                <!-- //sample27 -->

                <div id="sample28" class="sample">
                    <h3>28. 함수 유형 : 내부함수 : 스코프, 클로저 💛 나중에 다시 배움</h3>
                    <p class="t_desc">
                    </p>
<pre><code class="language-js">  function func(){
    function funcA(){
        document.write("함수가 실행되었습니다.");
    }
    funcA();

    function funcB(){
        document.write("함수가 실행되었습니다.");
    }
    funcB();
}
func();
</code></pre>
                    <div class="result">
                        <details>
                            <summary>결과 보기</summary>
                        </details>
                    </div>
                </div>
                <!-- //sample28 -->

                <div id="sample29" class="sample">
                    <h3>29. 함수 유형 : 클래스</h3>
                    <p class="t_desc">
                        내부함수 변경 , 객체 생성자 사용 (객체생성자의 개념을 클래스 함수에 그대로 사용할 수 있다.)<br>

                    </p>
<pre><code class="language-js">  {
    class study {
        constructor(num, name, job){
            this.num = num;
            this.name = name;
            this.job = job;
        } //class함수을 사용할 때 무조건 실행됨

        result(){
            document.write(this.num + ". 내 이름은 " + this.name + "이며, 직업은 " + this.job + "입니다.");
        }
    }
    
    const info1 = new study("1", "웹쓰", "웹퍼블리셔");
    const info2 = new study("2", "웹스토리보이", "프론트엔드 개발자");

    info1.result();
    info2.result();
    
}
</code></pre>
                    <div class="result">
                        <details>
                            <summary>결과 보기</summary>
                            1. 내 이름은 웹쓰이며, 직업은 웹퍼블리셔입니다.2. 내 이름은 웹스토리보이이며, 직업은 프론트엔드 개발자입니다.
                        </details>
                    </div>
                </div>
                <!-- //sample29 -->

                <div id="sample30" class="sample">
                    <h3>30. 함수 유형 : 클래스 : 상속하기</h3>
                    <p class="t_desc">
                    </p>
<pre><code class="language-js">{
    class study {
        constructor(num, name, job){
        this.num = num;
        this.name = name;
        this.job = job;
    }
    result(){
        document.write(this.num +  ". 내 이름은 " + this.name +  " 이며, 직업은 " + this.job +  " 입니다." );
    }
    }
    class study2 extends study{
        constructor(num, name, job,age){
        super(num, name, job);
        this.age = age;
        }
        result2(){
            document.write(this.num +  ". 내 이름은 " + this.name +  " 이며, 직업은 " + this.job +  " 이며 나이는 " + this.age + "살 입니다.");
        }
    }
    const info1 = new study("1","토매토","백수");
    const info2 = new study2("2","영양만점 토매토","프론트엔드 희망 백수",587);
    info1.result();
    info2.result();
    info2.result2();
}
</code></pre>
                    <div class="result">
                        <details>
                            <summary>결과 보기</summary>
                            1. 내 이름은 토매토 이며, 직업은 백수 입니다.2. 내 이름은 영양만점 토매토 이며, 직업은 프론트엔드 희망 백수 입니다.2. 내 이름은 영양만점 토매토 이며, 직업은 프론트엔드 희망 백수 이며 나이는 587살 입니다.
                        </details>
                    </div>
                </div>
                <!-- //sample30 -->




            </div>
        </div>
        <div id="parallax__top">Top</div>
        <!-- //parallax__top -->
    </main>
    <!-- //main -->
    <footer id="footer">
        <a href="mailto:praise1109@gmail.com">praise1109@gmail.com</a>
    </footer>
    <!-- //footer -->
    <script src="assets/js/highlight.min.js"> </script>
    <script>hljs.highlightAll();</script>
    <!-- <script>
        //01.선언적함수
        {
            function func() {
                document.write("함수가 실행되었습니다.1<br>");
            }
            func();
        }
        //02. 익명함수
        //변수 안에 함수를 넣어준다.
        //변수 = 숫자 문자 베열 특수값 언디파인드 함수 등 자료형 함수 -> 데이터 타입이라고 한다.
        {
            const func = function () {
                document.write("함수가 실행되었습니다.2<br>");
            }
            func();
        }
        //03. 매개변수 함수
        //1개 이상, 즉 여러개의 데이터를 전달할 수 있다.
        {
            // function func(str1, str2, str3){
            //     document.write(str1 + str2);
            // }
            // func("함수가 실행되었습니다.3<br>");

            function func(str) {
                document.write(str);
            }
            func("함수가 실행되었습니다.3<br>");
        }
        //04. 리턴값 함수
        {
            function func() {
                const str = "함수가 실행되었습니다.4";
                return str; //결과값과 종료값을 의미한다.
            }
            document.write(func());
        }
        //05. 화살표 함수 선언적함수
        {
            func = () => {
                document.write("함수가 실행되었습니다.5");
            }
            func();
        }
        //06. 화살표 함수 익명함수
        {
            func = () => {
                document.write("함수가 실행되었습니다.6");
            }
            func();
        }
        //07. 매개변수 
        {
            func = (str) => {
                document.write(str);
            }
            func("함수가 실행되었습니다.7");
        }
        //08. 리턴값 힘수 
        {
            func = () => {
                const str = "함수"
                return str; //결과값, 종료값을 의미한다.
            }
            document.write(func());
        }
        //09. 화살표 함수 : 익명 + 매개 + 리턴값 
        {
            const func = (str) => {
                return str;
            }
            document.write(func("함수가 실행되었습니다.9"));
        }
        //10. 화살표 함수 : 익명 + 매개 + 리턴값 + 괄호 생략
        //컨스트를 빼면 선언적 함수가 된다.
        {
            const func = str => {
                return str;
            }
            document.write(func("함수가 실행되었습니다.10"));
        }
        //11. 화살표 함수 : 익명 + 매개 + 리턴값 + 괄호 생략 + 리턴 생략
        //컨스트를 빼면 선언적 함수가 된다.
        {
            const func = str => str;

            document.write(func("함수가 실행되었습니다.11"));
        }
        //12. 화살표 함수 : 선언적 + 매개 + 리턴값 + 괄호 생략 + 리턴 생략
        {
            func = str => str;

            document.write(func("함수가 실행되었습니다.12"));
        }

        //데이터 실행 초급 끝//

        //13.
        {

        }


    </script> -->
    <!-- <script>
        //1
        {
            function func(){
               console.log("실행1"); 
            };
            func();
        }
        //2
        {
            const func = (function(){
               console.log("실행2"); 
            });
            func();
        }
        //3
        {
            function func(str){
                console.log(str);
            }
            func("실행3");
        }
        //4
        {
            function func(){
                const str = "실행4";
                return str;
            }
            console.log(func());
        }
        //5
        {
            func = () => {
                console.log("실행5");
            } 
            func();
        }
        //6
        {
            const func = () => {
                console.log("실행6");
            }
            func();
        }
        //7
        {
            func = (str) => {
                console.log("실행7");
            }
            func();
        }
        //8
        {
            func = () => {
                const str = "실행8";
                return str;
            }
            console.log(func());
        }
        //9
        {
            const func = (str) => {
                return str;
            }
            console.log(func("실행9"));
        }
        //10
        {
            const func = str => {
                return str;
            }
            console.log(func("실행10"));
        }
        //11
        {
            const func = str => str;
            console.log(func("실행11"));
        }
        //13 : 함수와 매개변수를 이용한 형태 : 매개변수를 통해 데이터 전달
        //함수의 특징1 : 함수는 실행문의 집합체이다.
        //함수의 특징2 : 함수를 재활용하는 것이 목적이다.
        {
            function func(num, str1, str2){
                document.write(num + ". " + str1 + "가 " + str2 + "되었습니다.13<br>");
            }
            func("1", "함수", "실행");
            func("2", "자바스크립트", "실행"); //재활용 : 함수를 두 번 쓸 필요가 없다. 
            func("3", "제이쿼리", "실행");
        }
        //14. 함수 유형 : 함수와 변수를 이용한 형태
        {
            function func(num, str1, str2){
                document.write(num + ". " + str1 + "가 " + str2 + "되었습니다.14<br>");
            }
            const youNum1 = 1;
            const youNum2 = 2;
            const youNum3 = 3;
            const youStr1 = "함수";
            const youStr2 = "자바스크립트";
            const youStr3 = "제이쿼리";
            const youCom1 = "실행";

            func(youNum1, youStr1, youCom1);
            func(youNum2, youStr2, youCom1);
            func(youNum3, youStr3, youCom1);

            //1. 함수가 실행되었습니다.
            //2. 자바스크립트가 실행되었습니다.
            //3. 제이쿼리가 실행되었습니다.
        }
        //15. 함수 유형 : 함수와 배열 , 객체를 이용한 형태 객체를 사용하여 데이터 전달
        {
            function func(num, str1, str2){
                document.write(num + ". " + str1 + "가 " + str2 + "되었습니다.15<br>");
            }

            const info = [
                {
                    num :  "1",
                    name :  "함수",
                    com :  "실행"
                },
                {
                    num :  "2",
                    name :  "자바스트립트",
                    com :  "실행"
                },
                {
                    num :  "3",
                    name :  "제이쿼리",
                    com :  "실행"
                }
            ];
            func(info[0].num, info[0].name, info[0].com);
            func(info[1].num, info[1].name, info[1].com);
            func(info[2].num, info[2].name, info[2].com);
        }
        //16. 함수 유형 : 객체 안에 변수와 함수를 이용한 형태
        //객체가 하나가 있을 땐 info 뒤에 []를 사용하지 않는다.
        //재사용이 불가하기 때문에 아래의 17번 식이 만들어짐
        {
            const info = {
                num1 : 1,
                name1 : "함수",
                word1 : "실행",
                num2 : 2,
                name2 : "자바스크립트",
                word2 : "실행",
                num3 : 3,
                name3 : "제이쿼리",
                word3 : "실행",

                result1 : function(){    
                    //객체 안에 함수를 넣은 상태 
                    document.write(info.num1 + ". " + info.name1 + "가 " + info.word1 + "되었습니다.16<br>");
                },
                result2 : function(){    
                    //객체 안에 함수를 넣은 상태 
                    document.write(info.num2 + ". " + info.name2 + "가 " + info.word2 + "되었습니다.16<br>");
                },
                result3 : function(){    
                    //객체 안에 함수를 넣은 상태 
                    document.write(info.num3 + ". " + info.name3 + "가 " + info.word3 + "되었습니다.16<br>");
                }
            }
            info.result1(); 
            info.result2(); 
            info.result3(); 
        }
        //17. 함수 유형 : 객체 생성자 함수 : 16번의 단점인 재사용을 위해 새로 만들어진 생성자 함수.
        // 눈감고 쓸 정도로 외워야 함 그만큼 많이 사용함.
        {
            function func(num, name, word){ //저장한 데이터를 변수에게 데이터 전달
                this.num = num; //재사용울 위해 const를 생략하고 this.를 붙인다.
                this.name = name;
                this.word = word;

                this.result = function(){
                    document.write(this.num + ". " + this.name + "가 " + this.word + "되었습니다.17<br>");
                }
            }

            //인스턴트 생성 - 데이터 저장
            const info1 = new func("1", "함수", "실행"); //데이터 저장  : this. : 이것을 저장하시오. 라는 의미!
            const info2 = new func("2", "자바스크립트", "실행");
            const info3 = new func("3", "제이쿼리", "실행");

            //객체 생성자를 출력하려면 꼭 인스턴트를 생성 한뒤 실행문을 써주어야 한다.

            //실행
            
            info1.result();
            info2.result();
            info3.result();
        }

        //18. 함수 유형 : 프로토타입 함수 : 메모리 까지 재사용
        //쓸데없는 데이터 말고 원하는 데이터만 가져오고 싶어 함수만 따로 빼기
        //왜 프로토타입을 쓰고 어디에 사용해야 하는가 => 면접 필수 질문!
        {
            function func(num, name, word){ //저장한 데이터를 변수에게 데이터 전달
                this.num = num; //재사용울 위해 const를 생략하고 this.를 붙인다.
                this.name = name;
                this.word = word;
            }
            func.prototype.result = function(){
                document.write(this.num + ". " + this.name + "가 " + this.word + "되었습니다.18<br>");
            }

            //인스턴트 생성 - 데이터 저장
            const info1 = new func("1", "함수", "실행"); //데이터 저장  : this. : 이것을 저장하시오. 라는 의미!
            const info2 = new func("2", "자바스크립트", "실행");
            const info3 = new func("3", "제이쿼리", "실행");

            //실행
            info1.result();
            info2.result();
            info3.result();
        }
        //19. 함수 유형 : 객체 리터럴 함수 : 함수를 리터럴 객체 안에 넣기
        //내가 원하는 데이터만 뽑아서 사용하기 위해 사용
        {
            function func(num, name, word){ //저장한 데이터를 변수에게 데이터 전달
                this.num = num; //재사용을 위해 const를 생략하고 this.를 붙인다.
                this.name = name;
                this.word = word;
            }
            func.prototype = {
                result1 : function(){
                    document.write(this.num + ". " + this.name + "가 " + this.word + "되었습니다.19<br>");
                },
                result2 : function(){
                    document.write(this.num + ". " + this.name + "가 " + this.word + "되었습니다.19<br>");
                },
                result3 : function(){
                    document.write(this.num + ". " + this.name + "가 " + this.word + "되었습니다.19<br>");
                }
            }

            //인스턴트 생성 - 데이터 저장
            const info1 = new func("1", "함수", "실행"); //데이터 저장  : this. : 이것을 저장하시오. 라는 의미!
            const info2 = new func("2", "자바스크립트", "실행");
            const info3 = new func("3", "제이쿼리", "실행");

            //실행
            info1.result1();
            info2.result2();
            info3.result3();
        }
        // 클래스 : 함수의 집합체 -> 함수형(요즘 트렌드 *) / 클래스형 (함수형에 클래스 장점을 추가시켜 리액트 훅이 생김))
        // 자바와 자바스크립트 구분 // css클래스와 자바스크립트의 클래스 구분하기!! 
        //20. 즉시실행함수 - func() 생략
        {
            //즉시실행 함수
            (function func (){
                document.write("즉시 실행 함수가 실행되었습니다.")
            })();

            //즉시실행 함수 화살표 함수
            (() => {
                document.write("즉시 실행 함수가 실행되었습니다.2")
            })();
        }
        //21. 파라미터 함수
        {
            function fun(str){
                document.write(str);
            }
            func("1. 함수가 실행되었습니다.21");

            function func(str = "2. 함수가 실행되었습니다.21"){
                document.write(str);
            }
            func();
        }
        //22. 아규먼트 함수
        {
            function func(a,b){
                document.write(argyments[0]);   //a
                document.write(argyments[1]);   //b
            }
            func("1.함수가 실행되었습니다.22","2.함수가 실행되었습니다.22");
        }
    </script> -->

    <script>
        //재귀함수 : 동시에 여러개 실행 즉 한번에 여러개의 함수를 동시에 실행
        // //반복적으로 사용할 경우
        // {
        //     function func(num) {
        //         if( num <= 1){
        //             document.write("함수가 실행되었습니다." + num);
        //         } else {
        //             document.write("함수가 실행되었습니다."+ num);
        //             func(num -1);
        //         }

        //     }

        //     func(10);
        // }

        // //애니메이션을 사용할 경우 1초에 60번실행이라는 기본 조건이 있기 때문에 무한대로 빠지지 않는다.
        // {
        //     function animation(){
        //         document.write("함수가 실행되었습니다.");

        //         requestAnimationFrame(animation)
        //     }
        //     animation();
        // }

        //보통적인 함수 2개 실행 방법 : 1번이 끝나고 2번 실행
        // {
        //     function func1() {
        //         document.write("함수가 실행되었습니다.1");
        //     }
        //     function func2() {
        //         document.write("함수가 실행되었습니다.2");
        //     }

        //     func1();
        //     func2();
        // }

          //콜백함수 : 2번(로딩소스)가 끝나고 1번 실행 : 즉 첫번째 함수가 실행 -> 두번째 함수가 실행 : 즉 순서대로 실행
        // {
        //     function func() {
        //         document.write("함수가 실행되었습니다.1");
        //     }
        //     //매개변수(인자값) 사용하여 마치 함수처럼 사용
        //     function callback(str) {
        //         document.write("함수가 실행되었습니다.2");
        //         str();
        //     }

        //     callback(func);

        //     //콜백이 실행되고 그 뒤 func가 실행된다. 즉 인자값을 이용하여 마치 함수처럼 사용하였기 때문이다. 실무에서 많이 사용
        // }

        //콜백함수 : 반복문
        // {
        //     function func(index) {
        //         document.write("함수가 실행되었습니다." + index);
        //     }

        //     function callback(num) {
        //        for(let i=1; i<=10; i++){
        //            num(i);
        //         }
        //     }

        //     callback(func);
        // }

        //콜백함수 : 동기 / 비동기
        // {
        //     function funcA(){
        //         document.write("funcA가 실행되었습니다. <br>");
        //     }
        //     function funcB(){
        //         document.write("funcB가 실행되었습니다. <br>");
        //     }

        //     funcA();
        //     funcB();

        //     // funcA가 실행되었습니다.
        //     // funcB가 실행되었습니다.
        // }

        //setTimeout을 걸었을 때 : 로딩소스
        // {
        //     function funcA(){
        //         setTimeout(() => {
        //            console.log("funcA가 실행되었습니다. <br>");
        //         },1000); //1초 후에 실행됨.
        //     }
        //     function funcB(){
        //         console.log("funcB가 실행되었습니다. <br>");
        //     }

        //     funcA();
        //     funcB();

        //     //b
        //     //a

        // }

        // 콜백함수 사용 시 : 원래 b가 먼저 실행된 후 a가 실행되어야 하지만 매개변수로 콜백을 사용하여서 실행문인 것 처럼 사용한다. <br> 그러면 a가 먼저 실행된 후 b가 실행된다. 즉 b도 3초 뒤에 a가 끝나고 b가 실행되는 것
        // 콜백함수의 용도는 순차적으로 코드를 실행시키기 위함. 콜백함수에 사용할 수 있는 함수는 대표적으로 이벤트 리스너와 셋타임아웃 등이 있다.
        // 콜백함수의 원리 : funcA 실행 해라. 그러나 실행 후 파리미터로 콜백을 넣어서 : 굳이 콜백 함수를 사용해서 순차적으로 사용하는 이유는 협업을 했을 때 각각 출력하고자 하는 값이 다를 때 콜백함수를 이용해서 원하는대로 순서를 바꿀 수 있기 때문.
        // {
        //     function funcA(callback){
        //         setTimeout(() => {
        //            console.log("funcA가 실행되었습니다. <br>");
        //            callback(); //실행문인 것처럼 훼이크
        //         }, 1000); //1초 후에 실행됨.
        //     }
        //     function funcB(){
        //         console.log("funcB가 실행되었습니다. <br>");
        //     }
        //     funcA(function(){
        //         funcB();
        //     });

        //     //a
        //     //b
        // }
        // {
        //     function funcA(callback){
        //         setTimeout(() => {
        //            console.log("funcA가 실행되었습니다. <br>");
        //            callback();
        //         }, 1000);
        //     }
        //     function funcB(callback){
        //         setTimeout(() => {
        //            console.log("funcB가 실행되었습니다. <br>");
        //            callback();
        //         }, 1000);
        //     }
        //     function funcC(callback){
        //         setTimeout(() => {
        //            console.log("funcC가 실행되었습니다. <br>");
        //            callback();
        //         }, 1000);
        //     }
        //     function funcD(callback){
        //         setTimeout(() => {
        //            console.log("funcD가 실행되었습니다. <br>");
        //            callback();
        //         }, 1000);
        //     }
        //     function funcE(){
        //         console.log("funcE가 실행되었습니다. <br>");
        //     }
        //     funcA(function(){
        //         funcB(function(){
        //             funcC(function(){
        //                 funcD(function(){
        //                     funcE();
        //                 });
        //             });
        //         });
        //     });

        //     //a
        //     //b
        //     //c
        //     //d
        //     //e
        // }
    
        //내부함수 : 함수안에 함수가 있는데 그 안에 변수값을 불러오냐 마냐의 차이
        // {
        //     function func(){
        //         function funcA(){
        //             document.write("함수가 실행되었습니다.");
        //         }
        //         funcA();

        //         function funcB(){
        //             document.write("함수가 실행되었습니다.");
        //         }
        //         funcB();
        //     }
        //     func();
        // }

        //29 클래스 : 내부함수 변경 , 객체 생성자 사용 (객체생성자의 개념을 클래스 함수에 그대로 사용할 수 있다.)
        //마음대로 변수를 사용할 수 있다.
        // {
            // class study {
            //     constructor(num, name, job){
            //         this.num = num;
            //         this.name = name;
            //         this.job = job;
            //     } //class함수을 사용할 때 무조건 실행됨

            //     result(){
            //         document.write(this.num + ". 내 이름은 " + this.name + "이며, 직업은 " + this.job + "입니다.");
            //     }
            // }
            
            // const info1 = new study("1", "웹쓰", "웹퍼블리셔");
            // const info2 = new study("2", "웹스토리보이", "프론트엔드 개발자");

            // info1.result();
            // info2.result();
            
        // }
        //30 클래스 : 상속 (클래스 함수도 상속받을 수 있다.)
        // {
        //     class study {
        //         constructor(num, name, job){
        //         this.num = num;
        //         this.name = name;
        //         this.job = job;
        //     }
        //     result(){
        //         document.write(this.num +  ". 내 이름은 " + this.name +  " 이며, 직업은 " + this.job +  " 입니다." );
        //     }
        //     }
        //     class study2 extends study{
        //         constructor(num, name, job,age){
        //         super(num, name, job);
        //         this.age = age;
        //         }
        //         result2(){
        //             document.write(this.num +  ". 내 이름은 " + this.name +  " 이며, 직업은 " + this.job +  " 이며 나이는 " + this.age + "살 입니다.");
        //         }
        //     }
        //     const info1 = new study("1","토매토","백수");
        //     const info2 = new study2("2","영양만점 토매토","프론트엔드 희망 백수",587);
        //     info1.result();
        //     info2.result();
        //     info2.result2();
        // }
            
   </script>

    <!-- !topbutton -->
    <script>
        // 01. top버튼 마지막 스크롤 값에만 보이게 하기
        // 문서 전체 높이 - 브라우저 높이( = 마지막 섹션에 스크롤이 위치했을 때  top버튼 띄우기)
        window.addEventListener("scroll", ()=> {
            let scrollTop = window.pageYOffset || window.scrollY || document.documentElement.scrollTop;
            if(document.documentElement.scrollHeight <= scrollTop + window.innerHeight){
                document.querySelector("#parallax__top").classList.add("show");
            }else {
                document.querySelector("#parallax__top").classList.remove("show");
            }
        });

        //02. top버튼 누르면 올라오게 하기
        document.querySelector("#parallax__top").addEventListener("click", ()=> {
            window.scrollTo({left: 0, top: 0, behavior:"smooth"}); //scrollTo : 절대 기준의 스크롤 값 설정으로 0px의 최상단을 기준으로 설정하는 것이다. (By는 현재 스크롤 값 위치와 이동하려는 스크롤위차값의 거리만 설정.)
        });

        window.addEventListener("scroll");
    </script>

</body>

</html>